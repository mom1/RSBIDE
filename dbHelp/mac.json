{
    "for": {
        "descr": "Инструкция for может использоваться для выполнения трёх различных задач.\n  1. Для эффективной реализации бесконечного цикла.\n\tВ этом случае не нужно задавать ни одного параметра цикла. Можно не указывать и скобки\n  2. Для реализации перебора элементов стандартных коллекций COM и RSL (это коллекции для которых можно создать объект енумератор).\n  3. Для выполнения цикла заданное количество раз.",
        "name": "for",
        "params": [
            {
                "descr": "Переменная цикла, последовательно получает значения элементов коллекции и объект, для которого можно запросить объект енумератор ",
                "name": "loopVar"
            },
            {
                "descr": "Задает начальное значение счетчика цикла. Если не задан принимается 0. ",
                "name": "beginExpr"
            },
            {
                "descr": "Конечное значение счетчика цикла. Если не задан принимается значение максимальное значения для типа V_INTEGER – 2147483647. ",
                "name": "endExpr"
            },
            {
                "descr": "Величина, на которую изменяется счетчик цикла при каждой итерации. \n\tЕсли не задан, то принимается 1, если значения endExpr больше чем или равно beginExpr и -1 в противном случае. ",
                "name": "deltaExpr"
            }
        ],
        "path": "Конструкция_языка/FOR",
        "syntax": "for (loopVar, beginExpr, endExpr, deltaExpr)\n\tсписок инструкций\nend",
        "type": "Statements"
    },
    "if": {
        "descr": "Условная инструкция IF в RSL.\nЕсли результатом сравнения какого-либо из них является истина,\nвыполняется список инструкций, который следует за данным условным выражением.\nОстальные условия при этом не анализируются.",
        "name": "IF",
        "params": [
            {
                "descr": "Первым анализируется условное выражение после IF. Если оно истинно, выполняется список инструкций",
                "name": "IF"
            },
            {
                "descr": "Количество конструкций ELIF не ограничено.\n\tПоследовательно, сверху вниз анализируются условные выражения после ELIF, если они есть",
                "name": "ELIF"
            },
            {
                "descr": "Первым анализируется условное выражение после IF.\n\tЕсли оно истинно, выполняется список инструкций",
                "name": "условное выражение"
            },
            {
                "descr": "Если в конструкции присутствует ELSE, то соответствующий список инструкций выполняется в том случае, если все условные выражения ложны",
                "name": "ELSE"
            }
        ],
        "path": "Конструкция_языка/IF",
        "syntax": "IF '('условное выражение')'\n\tсписок инструкций\nELIF '('условное выражение')'\n\tсписок инструкций\nELSE\n\tсписок инструкций\nEND",
        "type": "Statements"
    },
    "while": {
        "descr": "Для организации циклов в RSL используется инструкция WHILE",
        "name": "WHILE",
        "params": [
            {
                "descr": "Список инструкций выполняется до тех пор, пока остается истинным условное выражение\n\tЕсли условие ложно до входа в цикл, то список инструкций не выполняется ни разу",
                "name": "условное выражение"
            }
        ],
        "path": "Конструкция_языка/WHILE",
        "syntax": "WHILE '('условное выражение')'\n\tсписок инструкций\nEND",
        "type": "Statements"
    },
    "return": {
        "descr": "Инструкция RETURN применяется для выхода из процедуры или завершения всей RSL-программы. Во втором случае она должна быть указана вне любой процедуры.",
        "name": "RETURN",
        "params": [
            {
                "descr": "Выражение, заданное после слова RETURN, определяет возвращаемое процедурой значение.\n\tЕсли в инструкции завершения RSL-программы в качестве выражения задать текст, содержащийся в символьной константе или переменной типа String,\n\tон будет выведен на стандартное устройство вывода.",
                "name": "выражение"
            }
        ],
        "path": "Конструкция_языка/RETURN",
        "syntax": "RETURN [выражение];\n",
        "type": "Statements"
    },
    "break": {
        "descr": "Инструкция break прерывает выполнение цикла for или while и передает управление инструкции, следующей за инструкцией цикла.\nЕсли инструкция break вызвана вне инструкции цикла, то ее действие эквивалентно инструкции return без параметров.",
        "name": "BREAK",
        "params": [],
        "path": "Конструкция_языка/BREAK",
        "syntax": "break;",
        "type": "Statements"
    },
    "continue": {
        "descr": "Инструкция continue предназначена для непосредственного перехода к следующей итерации цикла без выполнения инструкций следующих после инструкции continue.\nЕсли инструкция continue вызвана вне инструкции цикла, то ее действие эквивалентно инструкции return без параметров.",
        "name": "CONTINUE",
        "params": [],
        "path": "Конструкция_языка/CONTINUE",
        "syntax": "continue;",
        "type": "Statements"
    },
    "var": {
        "descr": "Имена переменных RSL необходимо объявлять явно, используя определение VAR.\nИнициализация заключается в присвоении идентификатору переменной значения какого-либо выражения. Допускается инициализировать не все объявленные переменные.\nКонструкции, относящиеся к отдельным переменным, должны быть разделены запятой.\nПосле того, как определение VAR будет обнаружено компилятором в тексте программы хотя бы один раз,\nлюбая необъявленная явно переменная в текущем RSL-модуле приведет к сообщению об ошибке ",
        "name": "VAR",
        "params": [
            {
                "descr": "может содержать произвольное количество имен переменных",
                "name": "идентификатор"
            }
        ],
        "path": "Конструкция_языка/VAR",
        "syntax": "[local | private]VAR идентификатор [: имя типа ] [ '=' выражение ]\n',' идентификатор [: имя типа ] [ '=' выражение ]\n",
        "type": "Statements"
    },
    "const": {
        "descr": "Все символические константы должны быть объявлены явно при помощи определения CONST.\nКроме объявления имени, необходимо проинициализировать его каким-либо значением.\nСписок идентификаторов константы будет соответствовать типу заданной величины.",
        "name": "CONST",
        "params": [
            {
                "descr": "может содержать произвольное количество проинициализированных имен констант, разделенных запятыми.\n\tПопытка изменить значение любой из объявленных констант приведет к сообщению об ошибке при компиляции",
                "name": "идентификатор"
            }
        ],
        "path": "Конструкция_языка/CONST",
        "syntax": "[local | private]CONST идентификатор [: имя типа ] [ '=' выражение ]\n',' идентификатор [: имя типа ] [ '=' выражение ]\n",
        "type": "Statements"
    },
    "macro": {
        "descr": "Определение MACRO используется для описания процедуры RSL",
        "name": "MACRO",
        "params": [
            {
                "descr": "это имя процедуры, которое используется в инструкции вызова процедуры для выполнения",
                "name": "Идентификатор"
            },
            {
                "descr": "заключается в круглые скобки. Он имеет следующий вид:\n\t\tидентификатор [ : имя типа] {, идентификатор [ : имя типа]}\n\tЭтот список содержит разделенные запятыми идентификаторы переменных, которым при вызове данной процедуры будут присвоены значения фактических параметров.",
                "name": "Список формальных параметров"
            },
            {
                "descr": "может содержать любые инструкции и определения языка RSL, в том числе и другие определения MACRO.\n\tТаким образом, структура процедуры повторяет структуру RSL-программы",
                "name": "Список определений и инструкций"
            }
        ],
        "path": "Конструкция_языка/Определение процедур языка RSL/MACRO",
        "syntax": "[local | private] MACRO идентификатор [ '('список формальных параметров')'] [: имя типа ]\n\tсписок определений и инструкций\nEND\n",
        "type": "Statements"
    },
    "class": {
        "descr": "В языке RSL имеется возможность создавать классы и объекты. Классы и объекты, например, используются для поддержки программирования визуальной среды,\nв котором очень удобен объектно-ориентированный подход: такие ее специфические черты, как отчеты, кнопки, поля редактирования,\nпереключатели всегда можно представить в качестве объектов со своими свойствами и методами.\n\nВ языке RSL предусмотрено автоматическое создание объектов классов при первом обращении к декларированной переменной класса.\nЕсли конструктор класса имеет параметры, то в этом случае при создании объекта параметры будут иметь значение NULL\n\nЯзык RSL позволяет наследовать классы объектов от других классов.\nБазовый класс указывается в круглых скобках после ключевого слова CLASS.\nДля инициализации базового класса необходимо вызвать предопределенный метод, название которого образуется\nпутем добавления к имени класса приставки \"Init\". Вызов инициализатора базового класса может\nрасполагаться в любом месте определения дочернего класса\n\nМножественное наследование в языке RSL не поддерживается.\n\nОбращение к свойствам и методам класса осуществляется по имени\n\nКроме того, язык RSL поддерживает обращение к свойствам RSL-классов не только по имени, но и по индексу\n\nДля совместимости со стандартом автоматизации в языке RSL добавлена поддержка свойства по умолчанию.\nСвойством по умолчанию считается свойство, имя которого в выражении можно не указывать\n\nКлассы RSL могут иметь и свойства с параметрами. В настоящее время такие классы можно создать, например, при помощи специального инструмента DLM SDK.\nПараметры свойства аналогично параметрам метода указываются в круглых скобках\nКлассы языка RSL могут содержать деструктор, определяемый пользователем.\nДля его использования в определении класса необходимо указать метод с предопределенным именем Destructor.\nДеструктор вызывается автоматически при \"разрушении\" объекта. Если деструктор не определен, то все выделенные при создании объекта ресурсы освобождаются автоматически.\n\nВ коде методов все методы и свойства доступны непосредственно по имени.\nПри этом в каждый метод класса передается скрытый параметр this, представляющий собой ссылку на объект, для которого вызывается метод или свойство.\n\nСсылки на объекты хранятся в переменных RSL. При очистке переменной происходит удаление ссылки на объект.\nПеременная очищается перед присвоением ей нового значения либо при выходе из области видимости.\nТаким образом, объект класса будет существовать и его невозможно будет удалить до тех пор,\nпока на него есть хотя бы одна ссылка. При удалении последней ссылки на объект удаляется сам объект.\n\nОсобенностью использования RSL-классов, унаследованных от внешних классов, является невозможность обращения напрямую\nк методам родительского класса после того, как в дочернем классе эти методы были переопределены.\nДля этих целей служит стандартное свойство RSL-классов _extObj, возвращающее ссылку на внешний объект.\nЭто свойство позволяет переопределять методы базового класса в дочернем и сохраняет возможность вызова\nметодов базового класса",
        "name": "CLASS",
        "params": [
            {
                "descr": "это имя конструктора класса, которое используется при создании экземпляра данного класса.\n\tИспользование идентификатора класса в выражении создает экземпляр данного класса – объект.\n\tСписок формальных параметров содержит разделенные запятыми идентификаторы переменных, которые являются параметрами инициализатора объекта класса.\n\tВсе локальные переменные, находящиеся внутри определения класса, являются свойствами класса, а все локальные макропроцедуры – методами.\n\tЛюбой код внутри определения класса, не включенный в методы, является кодом конструктора",
                "name": "Идентификатор"
            },
            {
                "descr": "Если метод имеет параметры, то они указываются в круглых скобках аналогично параметрам макропроцедур RSL",
                "name": "Методы класса"
            }
        ],
        "path": "Конструкция_языка/CLASS",
        "syntax": "[local | private] Class [ '('идентификатор базового класса')'] идентификатор [' ('список формальных параметров')' ]\n\t<свойства класса>;\n\t<методы класса>;\nEnd\n",
        "type": "Statements"
    },
    "weakref": {
        "descr": "В языке RSL также предусмотрено использование так называемых \"слабых\" ссылок, которые не управляют временем жизни самого объекта,\nто есть объект можно удалить, если на него существуют \"слабые\" ссылки.\nМеханизм \"слабых\" ссылок в настоящее время поддерживается только для объектов классов, созданных на языке RSL.\n\"Слабая\" ссылка реализуется встроенным классом WeakRef",
        "name": "WEAKREF",
        "params": [
            {
                "descr": "Конструктор возвращает объект, который представляет собой \"слабую\" ссылку на объект obj. Этот объект в выражениях используется точно так же, как объект obj.\n\tПри попытке использовать \"слабую\" ссылку на объект, который уже удален, возникает ошибка времени исполнения.",
                "name": "WEAKREF"
            }
        ],
        "path": "Конструкция_языка/WEAKREF",
        "syntax": "WeakRef (obj:object) : object\n",
        "type": "Statements"
    },
    "with": {
        "descr": "Конструкция WITH применяется для обращения к конкретным экземплярам класса.",
        "name": "WITH",
        "params": [
            {
                "descr": "это имя переменной, содержащей ссылку на объект RSL-класса. Список инструкций выполняется для указанного объекта ",
                "name": "Идентификатор"
            }
        ],
        "path": "Конструкция_языка/WITH",
        "syntax": "WITH (идентификатор)\n\tсписок инструкций\nEND",
        "type": "Statements"
    },
    "import": {
        "descr": "В тексте программы может находиться директива IMPORT.\nИспользование этой директивы позволяет включить в текст макромодуля информацию из других файлов,\nчто дает возможность вынести часто используемые процедуры в отдельный файл\nи потом при необходимости подключать этот файл директивой IMPORT.\n\nДиректива IMPORT должна находиться вне определения макропроцедур\n\nДиректива IMPORT позволяет подключать:\n· другие RSL-модули, при этом имя модуля должно указываться без расширения\n\t(к нему будет по умолчанию добавлено расширение MAC);\n· DLM-модули – модули, созданные с помощью инструмента DLM SDK, которые имеют расширения D32, D16, DPM16, DLM.\n· встроенные в прикладную систему стандартные модули, которые написаны на языках C или C++.\n \nИмена модулей, подключаемых с помощью этой директивы, могут содержать русские буквы.\n\nПоиск указанных в директиве IMPORT файлов выполняется системой в следующей последовательности:\n· среди имен стандартных модулей, написанных на языке C/C++;\n· среди имен DLM-модулей;\n· среди имен текстовых файлов, имеющих расширение MAC. В этом случае система сначала осуществляет поиск файл\n\tс прекомпилированным кодом, который имеет такое же имя и расширение RSM, а затем ищет соответствующий ему макрофайл.\nЕсли для макрофайла существует актуальный файл с прекомпилированным кодом, то будет загружен соответствующий фай\nс расширением RSM. В противном случае загрузится файл с расширением MAC.",
        "name": "IMPORT",
        "params": [],
        "path": "Конструкция_языка/IMPORT",
        "syntax": "IMPORT \"FileName.mac\";\nimport FileName;",
        "type": "Statements"
    },
    "onerror": {
        "descr": "В языке RSL можно осуществить \"перехват\" любой ошибки, возникающей во время выполнения, не допустив аварийного завершения RSL-программы.\nДля этого любая макропроцедура RSL или метод класса может иметь обработчик ошибок\n\nЕсли какая-либо инструкция в теле макропроцедуры Test или инструкция в процедурах, вызванных из Test,\nгенерирует ошибку, то управление передается на первую инструкцию для обработки ошибок после ключевого слова OnError,\nи аварийного завершения RSL-программы не происходит.\n\nЕсли обработчику ошибок нужна информация о произошедшей ошибке, после ключевого слова OnError\nв скобках необходимо указать имя переменной (эта переменная может не декларироваться в теле макропроцедуры\nпри помощи ключевого слова VAR), которая после возникновения сбоя получит ссылку на\nспециальный объект класса TrslError, содержащий информацию о данной ошибке.\n\nОбъект класса TrslError имеет следующие свойства:\n· Codeкод ошибки;\n· Messageстрока, описывающая ошибку;\n· Moduleназвание модуля RSL, вызвавшего ошибку;\n· Lineстрока модуля, в которой произошла ошибка;\n· AxCodeкод ошибки ActiveX-объекта;\n· AxMesстрока с информацией об ошибке ActiveX-объекта.\n\nВ обработчике OnError можно получить информацию об ошибке пользователя при помощи обращения к полю err.\n\nЧтобы в обработчике заново сгенерировать ту же самую ошибку для передачи ее другому обработчику в цепочке\nвызовов макропроцедур или обработчику RSL, необходимо вызвать стандартную RSL-процедуру RunError без параметров.\n\nВ макромодуле, как и в макропроцедуре, можно реализовать обработчик ошибок.\nКлючевое слово END при этом не обязательно.\n\nПередача управления обработчику OnError происходит также при прерывании пользователем RSL-программы\nпо Ctrl+Break и при завершении программы процедурой Exit.\nВ обоих случаях генерируются специальные ошибки времени выполнения: для Ctrl+Break - код ошибки равен 17,\nдля Exit - код ошибки равен 0. Эти ошибки обрабатываются обработчиками OnError, как и любые другие ошибки RSL\nвремени выполнения. Но данные ошибки всегда пробрасываются дальше, даже если обработчик OnError не делает этого явно.\n\nКод, вызвавший RSL, в случае Ctrl+Break и Exit считает, что ошибок выполнения не было.",
        "name": "OnError",
        "params": [],
        "path": "ONERROR",
        "syntax": "Macro Test\n\t<инструкции RSL>\nOnError(er)\n\t<инструкции для обработки ошибок>\nEnd;",
        "type": "Statements"
    },
    "getint": {
        "descr": "В случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetInt",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа Integer с именем id\n\tЗначение, которое эта переменная имела до вызова процедуры, используется как значение по умолчанию",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            },
            {
                "descr": "Третий параметр задает ширину поля ввода. Если он не задан, то по умолчанию ширина поля ввода принимается равной 12 символам.",
                "name": "len"
            },
            {
                "descr": "Четвертый параметр имеет тип Bool. Если он равен TRUE, то вводимая информация отображается на экране звездочками.",
                "name": "hide"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETINT",
        "syntax": "GetInt ( id , prompt, len , hide)\n",
        "type": "Statements"
    },
    "getdouble": {
        "descr": "В случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetDouble",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа Double с именем id\n\tЗначение, которое эта переменная имела до вызова процедуры, используется как значение по умолчанию",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            },
            {
                "descr": "Третий параметр задает ширину поля ввода. Если он не задан, то по умолчанию ширина поля ввода принимается равной 24 символам.",
                "name": "len"
            },
            {
                "descr": "Четвертый параметр имеет тип Bool. Если он равен TRUE, то вводимая информация отображается на экране звездочками.",
                "name": "hide"
            },
            {
                "descr": "Пятый параметр имеет тип Integer и задает количество знаков после десятичной точки.",
                "name": "pos"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETDOUBLE",
        "syntax": "GetDouble ( id, prompt, len, hide, pos)\n",
        "type": "Statements"
    },
    "getmoney": {
        "descr": "В случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetMoney",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа Money с именем id\n\tЗначение, которое эта переменная имела до вызова процедуры, используется как значение по умолчанию",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            },
            {
                "descr": "Третий параметр задает ширину поля ввода. Если он не задан, то по умолчанию ширина поля ввода принимается равной 18 символам.",
                "name": "len"
            },
            {
                "descr": "Четвертый параметр имеет тип Bool. Если он равен TRUE, то вводимая информация отображается на экране звездочками.",
                "name": "hide"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/MONEY",
        "syntax": "GetMoney ( id, prompt, len, hide)\n",
        "type": "Statements"
    },
    "getstring": {
        "descr": "В случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetString",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа String с именем id\n\tЗначение, которое эта переменная имела до вызова процедуры, используется как значение по умолчанию",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            },
            {
                "descr": "Третий параметр задает ширину поля ввода. Если он не задан, то по умолчанию ширина поля ввода принимается равной 70 символам.",
                "name": "len"
            },
            {
                "descr": "Четвертый параметр имеет тип Bool. Если он равен TRUE, то вводимая информация отображается на экране звездочками.",
                "name": "hide"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETSTRING",
        "syntax": "GetString ( id, prompt, len, hide)\n",
        "type": "Statements"
    },
    "getstringr": {
        "descr": "Процедура используется для ввода числовых строк (например, номеров лицевых счетов).\nКроме этого, она выравнивает введенное значение по правому краю поля ввода\nВ случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetStringR",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа String с именем id\n\tЗначение, которое эта переменная имела до вызова процедуры, используется как значение по умолчанию",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            },
            {
                "descr": "Третий параметр задает ширину поля ввода. Если он не задан, то по умолчанию ширина поля ввода принимается равной 9 символам.",
                "name": "len"
            },
            {
                "descr": "Четвертый параметр имеет тип Bool. Если он равен TRUE, то вводимая информация отображается на экране звездочками.",
                "name": "hide"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETSTRINGR",
        "syntax": "GetStringR ( id, prompt, len, hide)\n",
        "type": "Statements"
    },
    "getdate": {
        "descr": "Ширина поля ввода всегда равна 10 символам.\nВ случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetDate",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа Date с именем id\n\tЗначение, которое эта переменная имела до вызова процедуры, используется как значение по умолчанию",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            },
            {
                "descr": "Третий параметр имеет тип Bool. Если он равен TRUE, то вводимая информация отображается на экране звездочками.",
                "name": "hide"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETDATE",
        "syntax": "GetDate (id, prompt, hide)\n",
        "type": "Statements"
    },
    "gettrue": {
        "descr": "Если пользователь утвердительно ответил на запрос, то переменной id присваивается значение TRUE, и процедура возвращает TRUE.\nЕсли в качестве параметра процедуры id используется константа (TRUE или FALSE), ответ пользователя можно определить только по возвращаемому значению.\nШирина поля ввода игнорируется.\nВ случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetTRUE",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа Bool с именем id",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETTRUE",
        "syntax": "GetTRUE (id, prompt)\n",
        "type": "Statements"
    },
    "gettime": {
        "descr": "В случае успешной работы процедура возвращает TRUE.\nЕсли пользователь закрыл окно ввода с помощью клавиши Esc, возвращается FALSE, при этом значение переменной id не изменяется.",
        "name": "GetTime",
        "params": [
            {
                "descr": "Процедура присваивает введенное пользователем значение переменной типа Time с именем id",
                "name": "id"
            },
            {
                "descr": "Второй параметр типа String задает текст приглашения к вводу.\n\tЕсли он отсутствует, то по умолчанию принимается следующий текст: \"Введите значение: \".",
                "name": "prompt"
            }
        ],
        "path": "Встроенные процедуры/Стандартные процедуры ввода данных/GETTIME",
        "syntax": "GetTime (id, prompt)\n",
        "type": "Statements"
    },
    "asize": {
        "descr": "Процедура возвращает текущий размер массива val.\nЕсли указан второй параметр, то старый массив удаляется, и распределяется пустой массив размером newsize.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "Asize",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/ASIZE",
        "syntax": "Asize (val, newsize)",
        "type": "Statements"
    },
    "date": {
        "descr": "Процедура возвращает переменную типа Date.\nПроцедуре можно передать от одного до трех параметров типа Integer.\nПереданные значения заменят соответствующие им части текущей даты.\nЕсли нужно изменить только год и оставить текущий день и месяц, необходимо передать в качестве первого и второго\nпараметров значение любого типа, отличного от Integer.\n\nПроцедуре также можно передать в качестве первого параметра строку вида \"dd.mm.yy\" или \"dd.mm.yyyy\",\nв результате переданное значение будет преобразовано к соответствующей дате.\n\nПроцедура также может принимать в качестве параметра значения типа Date и Dttm, которые будут преобразованы в переменную типа Date.\n\nDate - создаёт V_DATE из V_STRING, V_INTEGER(s), V_DTTM, V_DATE.\n\nЕсли при вызове процедуры параметры не указаны, она вернет текущую дату.",
        "name": "Date",
        "params": [
            {
                "descr": "задает число",
                "name": "day"
            },
            {
                "descr": "задает месяц",
                "name": "mon"
            },
            {
                "descr": "задает год",
                "name": "year"
            }
        ],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DATE",
        "syntax": "Date (day, mon, year)",
        "type": "Statements"
    },
    "datesplit": {
        "descr": "Процедура получает в качестве первого параметра date переменную типа Date\nи возвращает через параметры day, mon, year, имеющие тип Integer,\nсоответственно, день, месяц и год для заданной даты.\n\nЕсли нужно получить только какую-нибудь одну составляющую даты,\nпропущенные компоненты заменяются нулевыми значениями, а конец списка опускается.\n\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "DateSplit",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DATESPLIT",
        "syntax": "DateSplit (date, day, mon, year)",
        "type": "Statements"
    },
    "decimal": {
        "descr": "Процедура возвращает преобразованное в тип Decimal значение параметра val.",
        "name": "Decimal",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DECIMAL",
        "syntax": "Decimal (val:variant) : decimal",
        "type": "Statements"
    },
    "double": {
        "descr": "Процедура возвращает преобразованное в тип Double значение типа Integer, Money или String,\nпереданное через параметр val.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "Double",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DOUBLE",
        "syntax": "Double ( val )",
        "type": "Statements"
    },
    "doublel": {
        "descr": "Процедура возвращает преобразованное в тип DoubleL значение типа Integer, Double, Money или String,\nпереданное через параметр val.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "DoubleL",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DOUBLEL",
        "syntax": "DoubleL ( val )",
        "type": "Statements"
    },
    "dttm": {
        "descr": "Процедура принимает в качестве первого параметра переменную типа Date,\nв качестве второго – переменную типа V_TIME и возвращает величину типа Dttm,\nсостоящую из двух компонент: даты и времени.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.\nDtTm - создаёт V_DTTM из V_DATE, V_TIME, V_DTTM.",
        "name": "DtTm",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DTTM",
        "syntax": "DtTm ( date, time )",
        "type": "Statements"
    },
    "dttmsplit": {
        "descr": "Процедура получает в качестве первого параметра величину d типа Dttm и возвращает две ее составляющие:\nдату и время через параметры dt и tm.\nВ качестве первого параметра также можно передать значение типа Date или Time, в этом случае процедура вернет\nдату либо время в соответствующем параметре.\nDtTmSplit может первым параметром принимать V_DATE, V_TIME, V_DTTM.",
        "name": "DtTmSplit",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/DTTMSPLIT",
        "syntax": "DtTmSplit (d, dt, tm)",
        "type": "Statements"
    },
    "floor": {
        "descr": "Процедура возвращает наибольшее целое число, меньшее или равное заданному параметру.\nДанная процедура применяется для значений типа Double, DoubleL или Money\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "Floor",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/FLOOR",
        "syntax": "Floor ( val )",
        "type": "Statements"
    },
    "int": {
        "descr": "Процедура возвращает наибольшее целое число, меньшее или равное заданному параметру.\nДанная процедура применяется для значений типа Double, DoubleL или Money\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "Int",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/INT",
        "syntax": "Int ( val )",
        "type": "Statements"
    },
    "mkstr": {
        "descr": "Процедура возвращает строку типа String конкретной длины, состоящую из заданного символа-заполнителя.\nВид символа-заполнителя определяется первым параметром val1, который может быть числом или строкой.\nЕсли это число имеет тип Integer, то оно будет расценено как код символа-заполнителя.\nЕсли параметр val1 представляет собой строку (тип String), то в качестве заполнителя используется ее первый символ.\nВторой параметр val2 задает длину возвращаемой строки.\n\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "MkStr",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/MKSTR",
        "syntax": "MkStr ( val1, val2 )",
        "type": "Statements"
    },
    "money": {
        "descr": "Процедура возвращает преобразованное в тип Money значение параметра типа String, Integer, Double или DoubleL.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "Money",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/MONEY",
        "syntax": "Money ( val )",
        "type": "Statements"
    },
    "monname": {
        "descr": "Процедура возвращает название месяца, номер которого (от 1 до 12) передан через параметр mon типа Integer.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "MonName",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/MONNAME",
        "syntax": "MonName ( mon )",
        "type": "Statements"
    },
    "numtostr": {
        "descr": "1. Процедура NumToStr возвращает значение числа val прописью.\nПараметры n1, n2 и n3 задают три возможных вида сущности, количество которой задается параметром val.\nПараметр isMan имеет значение TRUE для сущности мужского рода и FALSE для сущности женского рода.\nПо умолчанию параметр принимает значение FALSE.\nПараметр prec задает максимальное количество знаков после десятичной точки.\nМожет быть задано от 0 до 5 знаков. По умолчанию используется значение 2.\n\n2. Процедура NumToStr принимает дополнительный параметр с количеством знаков после точки. По умолчанию принимается 2.",
        "name": "NumToStr",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/NUMTOSTR",
        "syntax": "NumToStr (val, n1:string, n2:string, n3:string, isMan:bool, prec:integer) : string",
        "type": "Statements"
    },
    "round": {
        "descr": "Процедура Round возвращает округлённое значение переменной типа Money или Decimal,\nпереданной в качестве параметра val.\nОкругление может производиться до рублей, если параметр pos равен 0, или до копеек, если pos равен 2.\nЕсли параметр pos не задан, то по умолчанию он принимается равным 2.",
        "name": "Round",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/ROUND",
        "syntax": "Round (val:Variant [, pos:integer]):money",
        "type": "Statements"
    },
    "string": {
        "descr": "Данная процедура принимает произвольное количество параметров и возвращает\nсформированную из них отформатированную строку.\nПри записи параметров, так же, как и в процедурах Print и PrintLn, могут быть указаны\nспециальные символы форматирования.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "String",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/STRING",
        "syntax": "String ( val {, val})",
        "type": "Statements"
    },
    "time": {
        "descr": "Процедура возвращает переменную типа Time.\nПроцедуре можно передать от одного до четырех параметров типа Integer.\nПервый задает часы, второй – минуты, третий – секунды, четвертый – сотые доли секунды.\nПереданные значения заменят соответствующие им части текущего времени.\nПередача не всех параметров осуществляется так же, как для процедуры Date.\nПроцедуре также можно передать в качестве первого параметра строку вида \"hh:mm:ss.nn\", \"hh:mm:ss\" или \"hh:mm\",\nв результате переданное значение будет преобразовано к соответствующему времени.\nЕсли время задается строкой вида \"hh:mm:ss.nn\", то процедуре можно передать второй строковый параметр,\nзадающий символ-разделитель между секундами и сотыми долями секунды. По умолчанию используется символ \".\".\nПроцедура может принимать в качестве параметра значения типа Time и Dttm,\nкоторые будут преобразованы в переменную типа Time.\nTime - создаёт V_TIME из V_STRING, V_INTEGER(s), V_DTTM, V_TIME.\n\nЕсли при вызове процедуры параметры не указаны, она вернет текущее время.",
        "name": "Time",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/TIME",
        "syntax": "Time [ ( hour, min, sec, msec ) ]",
        "type": "Statements"
    },
    "timesplit": {
        "descr": "Процедура принимает в качестве первого (входного) параметра переменную типа Time\nи возвращает в выходных параметрах hour, min, sec типа Integer компоненты заданного времени: часы, минуты и секунды.\nДопускается указывать в выходных параметрах только интересующие пользователя компоненты времени.\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "TimeSplit",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/TIMESPLIT",
        "syntax": "TimeSplit (time, hour, min, sec)",
        "type": "Statements"
    },
    "valtype": {
        "descr": "Процедура возвращает код типа переменной, переданной через параметр val.\nВ зависимости от типа данных возвращаемым значением может быть одно из следующих значений\n\nV_INTEGER – для целых чисел со знаком длиной 4 байта\nV_STRING – для символьных строк\nV_DOUBLE – для чисел с плавающей точкой длиной 8 байт\nV_DOUBLEL – для чисел с плавающей точкой длиной 10 байт. При задании констант этого типа необходимо в конце числа указать символ L (например: 1234.567L)\nV_BOOL – для логических переменных\nV_MONEY – для денежных сумм\nV_DECIMAL – для целых чисел длиной до 8 байт с точкой, отделяющей 4 знака\nV_DATE – для дат (даты представляются в виде ДД.ММ.ГГГГ)\nV_TIME – для времени (время представляется в виде ЧЧ:ММ:СС)\nV_DTTM – для даты и времени совместно\nV_UNDEF – для значений неопределенного типа\nV_AREF – для ссылок на массив (объект типа ARRAY)\nV_TREF – для ссылок на текстовый файл (объект типа TXTFILE)\nV_DREF – для ссылок на файл формата DBF (объект типа DBFFILE)\nV_GENOBJ – для ссылок на объект класса\nV_PROC – для ссылок на процедуру\nV_R2M – для ссылок на метод класса (переменная такого типа возвращается процедурой R2M)\n\nЕсли процедура не может выполнить преобразование, она возвращает нулевое значение соответствующего типа.",
        "name": "ValType",
        "params": [],
        "path": "Встроенные процедуры/Процедуры преобразования типа/VALTYPE",
        "syntax": "ValType ( val )",
        "type": "Statements"
    },
    "codefor": {
        "descr": "Процедура возвращает код ASCII для первого символа в строке string.",
        "name": "CodeFor",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/CODEFOR",
        "syntax": "CodeFor ( string )",
        "type": "Statements"
    },
    "index": {
        "descr": "Процедура возвращает номер позиции строки string2 в строке string1 или 0, если строка string2 не найдена в string1.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "Index",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/INDEX",
        "syntax": "Index ( string1, string2 )",
        "type": "Statements"
    },
    "strbrk": {
        "descr": "Процедура возвращает позицию первого из символов в строке string1, который содержится также и в строке string2.\nЕсли в строке string1 нет ни одного из символов строки string2, процедура возвращает 0.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrBrk",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRBRK",
        "syntax": "StrBrk ( string1, string2 )",
        "type": "Statements"
    },
    "strfor": {
        "descr": "Процедура возвращает строку, состоящую из одного символа, код ASCII которого равен number.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrFor",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRFOR",
        "syntax": "StrFor ( number )",
        "type": "Statements"
    },
    "strlen": {
        "descr": "Процедура возвращает длину строки символов, заданной в качестве параметра.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrLen",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRLEN",
        "syntax": "StrLen ( string )",
        "type": "Statements"
    },
    "strlwr": {
        "descr": "Процедура возвращает копию строки string, преобразованную в символы нижнего регистра.\nНеобязательный параметр len задает количество символов, которые необходимо преобразовать.\nЕсли параметр len не указан, все символы строки string будут преобразованы в символы нижнего регистра.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrLwr",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRLWR",
        "syntax": "StrLwr ( string [, len] )",
        "type": "Statements"
    },
    "strset": {
        "descr": "Процедура записывает строку string2 в строку string1, начиная с позиции строки string1, определенной вторым параметром типа Integer.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrSet",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRSET",
        "syntax": "StrSet ( string1, integer, string2 )",
        "type": "Statements"
    },
    "strsplit": {
        "descr": "Процедура разбивает длинную строку, заданную в качестве первого параметра типа String, на несколько сегментов.\nРезультат помещается в одномерный массив, определенный вторым параметром типа Array.\nДлина каждого сегмента задается третьим параметром len, имеющим тип Integer.\nЕсли к тому же задан параметр len_first, он используется как длина первого сегмента массива.\nУказав последний параметр процедуры minseg, можно задать минимальное число сегментов.\nВ том случае, если реальное число созданных сегментов меньше заданного минимального, лишние элементы массива\narray инициализируются пустыми строками.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrSplit",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRSPLIT",
        "syntax": "StrSplit ( string, array, len [, len_first] [, minseg] )",
        "type": "Statements"
    },
    "strsplit2": {
        "descr": "Процедура аналогична процедуре StrSplit и возвращает объект типа TArray, содержащий полученные строки.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrSplit2",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRSPLIT2",
        "syntax": "StrSplit2 (source:string, len:integer [, len_first:integer] [, minseg:integer]) : TArray",
        "type": "Statements"
    },
    "strsubst": {
        "descr": "Процедура ищет в строке source подстроки strToFind и заменяет их строками strToReplace. Возвращаемым значением является результирующая строка.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrSubst",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRSUBST",
        "syntax": "StrSubst ( sourse, strToFind, strToReplace )",
        "type": "Statements"
    },
    "strupr": {
        "descr": "Процедура возвращает копию строки string, преобразованную в символы верхнего регистра.\nНеобязательный параметр len задает количество символов, которые необходимо преобразовать.\nЕсли параметр len не указан, все символы строки string будут преобразованы в символы верхнего регистра.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "StrUpr",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/STRUPR",
        "syntax": "StrUpr ( string [,len] )",
        "type": "Statements"
    },
    "substr": {
        "descr": "Процедура возвращает часть строки string, которая начинается с позиции integer1.\nТретий параметр не обязателен. Если он указан, то извлекается подстрока длиной integer2.\nВ противном случае извлекается подстрока с позиции integer1 до конца строки string.\nПри неправильно заданных параметрах возвращается пустая строка.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "SubStr",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/SUBSTR",
        "syntax": "SubStr ( string, integer1 [, integer2] )",
        "type": "Statements"
    },
    "toansi": {
        "descr": "Процедура конвертирует строку, заданную параметром string, из OEM в ANSI. Возвращаемым значением является преобразованная строка.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "ToANSI",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/TOANSI",
        "syntax": "ToANSI (string)",
        "type": "Statements"
    },
    "tooem": {
        "descr": "Процедура конвертирует строку, заданную параметром string, из ANSI в OEM. Возвращаемым значением является преобразованная строка.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "ToOEM",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/TOOEM",
        "syntax": "ToOEM (string)",
        "type": "Statements"
    },
    "trim": {
        "descr": "Процедура удаляет начальные и конечные пробелы из строки типа String, заданной в качестве параметра, и возвращает результат.\nПри работе с символьными строками считается, что первый символ находится в позиции с номером 1.",
        "name": "Trim",
        "params": [],
        "path": "Встроенные процедуры/Процедуры для работы со строками/TRIM",
        "syntax": "Trim ( string )",
        "type": "Statements"
    }
}
