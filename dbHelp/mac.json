{
    "for": {
        "descr": "Инструкция for может использоваться для выполнения трёх различных задач.\n  1. Для эффективной реализации бесконечного цикла.\n\tВ этом случае не нужно задавать ни одного параметра цикла. Можно не указывать и скобки\n  2. Для реализации перебора элементов стандартных коллекций COM и RSL (это коллекции для которых можно создать объект енумератор).\n  3. Для выполнения цикла заданное количество раз.",
        "name": "for",
        "params": [
            {
                "descr": "Переменная цикла, последовательно получает значения элементов коллекции и объект, для которого можно запросить объект енумератор ",
                "name": "loopVar"
            },
            {
                "descr": "Задает начальное значение счетчика цикла. Если не задан принимается 0. ",
                "name": "beginExpr"
            },
            {
                "descr": "Конечное значение счетчика цикла. Если не задан принимается значение максимальное значения для типа V_INTEGER – 2147483647. ",
                "name": "endExpr"
            },
            {
                "descr": "Величина, на которую изменяется счетчик цикла при каждой итерации. \n\tЕсли не задан, то принимается 1, если значения endExpr больше чем или равно beginExpr и -1 в противном случае. ",
                "name": "deltaExpr"
            }
        ],
        "path": "Конструкция_языка/FOR",
        "syntax": "for (loopVar, beginExpr, endExpr, deltaExpr)\n\tсписок инструкций\nend",
        "type": "Statements"
    },
    "if": {
        "descr": "Условная инструкция IF в RSL.\nЕсли результатом сравнения какого-либо из них является истина,\nвыполняется список инструкций, который следует за данным условным выражением.\nОстальные условия при этом не анализируются.",
        "name": "IF",
        "params": [
            {
                "descr": "Первым анализируется условное выражение после IF. Если оно истинно, выполняется список инструкций",
                "name": "IF"
            },
            {
                "descr": "Количество конструкций ELIF не ограничено.\n\tПоследовательно, сверху вниз анализируются условные выражения после ELIF, если они есть",
                "name": "ELIF"
            },
            {
                "descr": "Первым анализируется условное выражение после IF.\n\tЕсли оно истинно, выполняется список инструкций",
                "name": "условное выражение"
            },
            {
                "descr": "Если в конструкции присутствует ELSE, то соответствующий список инструкций выполняется в том случае, если все условные выражения ложны",
                "name": "ELSE"
            }
        ],
        "path": "Конструкция_языка/IF",
        "syntax": "IF '('условное выражение')'\n\tсписок инструкций\nELIF '('условное выражение')'\n\tсписок инструкций\nELSE\n\tсписок инструкций\nEND",
        "type": "Statements"
    },
    "while": {
        "descr": "Для организации циклов в RSL используется инструкция WHILE",
        "name": "WHILE",
        "params": [
            {
                "descr": "Список инструкций выполняется до тех пор, пока остается истинным условное выражение\n\tЕсли условие ложно до входа в цикл, то список инструкций не выполняется ни разу",
                "name": "условное выражение"
            }
        ],
        "path": "Конструкция_языка/WHILE",
        "syntax": "WHILE '('условное выражение')'\n\tсписок инструкций\nEND",
        "type": "Statements"
    },
    "return": {
        "descr": "Инструкция RETURN применяется для выхода из процедуры или завершения всей RSL-программы. Во втором случае она должна быть указана вне любой процедуры.",
        "name": "RETURN",
        "params": [
            {
                "descr": "Выражение, заданное после слова RETURN, определяет возвращаемое процедурой значение.\n\tЕсли в инструкции завершения RSL-программы в качестве выражения задать текст, содержащийся в символьной константе или переменной типа String,\n\tон будет выведен на стандартное устройство вывода.",
                "name": "выражение"
            }
        ],
        "path": "Конструкция_языка/RETURN",
        "syntax": "RETURN [выражение];\n",
        "type": "Statements"
    },
    "break": {
        "descr": "Инструкция break прерывает выполнение цикла for или while и передает управление инструкции, следующей за инструкцией цикла.\nЕсли инструкция break вызвана вне инструкции цикла, то ее действие эквивалентно инструкции return без параметров.",
        "name": "BREAK",
        "params": [],
        "path": "Конструкция_языка/BREAK",
        "syntax": "break;",
        "type": "Statements"
    },
    "continue": {
        "descr": "Инструкция continue предназначена для непосредственного перехода к следующей итерации цикла без выполнения инструкций следующих после инструкции continue.\nЕсли инструкция continue вызвана вне инструкции цикла, то ее действие эквивалентно инструкции return без параметров.",
        "name": "CONTINUE",
        "params": [],
        "path": "Конструкция_языка/CONTINUE",
        "syntax": "continue;",
        "type": "Statements"
    },
    "var": {
        "descr": "Имена переменных RSL необходимо объявлять явно, используя определение VAR.\nИнициализация заключается в присвоении идентификатору переменной значения какого-либо выражения. Допускается инициализировать не все объявленные переменные.\nКонструкции, относящиеся к отдельным переменным, должны быть разделены запятой.\nПосле того, как определение VAR будет обнаружено компилятором в тексте программы хотя бы один раз,\nлюбая необъявленная явно переменная в текущем RSL-модуле приведет к сообщению об ошибке ",
        "name": "VAR",
        "params": [
            {
                "descr": "может содержать произвольное количество имен переменных",
                "name": "идентификатор"
            }
        ],
        "path": "Конструкция_языка/VAR",
        "syntax": "[local | private]VAR идентификатор [: имя типа ] [ '=' выражение ]\n',' идентификатор [: имя типа ] [ '=' выражение ]\n",
        "type": "Statements"
    },
    "const": {
        "descr": "Все символические константы должны быть объявлены явно при помощи определения CONST.\nКроме объявления имени, необходимо проинициализировать его каким-либо значением.\nСписок идентификаторов константы будет соответствовать типу заданной величины.",
        "name": "CONST",
        "params": [
            {
                "descr": "может содержать произвольное количество проинициализированных имен констант, разделенных запятыми.\n\tПопытка изменить значение любой из объявленных констант приведет к сообщению об ошибке при компиляции",
                "name": "идентификатор"
            }
        ],
        "path": "Конструкция_языка/CONST",
        "syntax": "[local | private]CONST идентификатор [: имя типа ] [ '=' выражение ]\n',' идентификатор [: имя типа ] [ '=' выражение ]\n",
        "type": "Statements"
    },
    "macro": {
        "descr": "Определение MACRO используется для описания процедуры RSL",
        "name": "MACRO",
        "params": [
            {
                "descr": "это имя процедуры, которое используется в инструкции вызова процедуры для выполнения",
                "name": "Идентификатор"
            },
            {
                "descr": "заключается в круглые скобки. Он имеет следующий вид:\n\t\tидентификатор [ : имя типа] {, идентификатор [ : имя типа]}\n\tЭтот список содержит разделенные запятыми идентификаторы переменных, которым при вызове данной процедуры будут присвоены значения фактических параметров.",
                "name": "Список формальных параметров"
            },
            {
                "descr": "может содержать любые инструкции и определения языка RSL, в том числе и другие определения MACRO.\n\tТаким образом, структура процедуры повторяет структуру RSL-программы",
                "name": "Список определений и инструкций"
            }
        ],
        "path": "Конструкция_языка/Определение процедур языка RSL/MACRO",
        "syntax": "[local | private] MACRO идентификатор [ '('список формальных параметров')'] [: имя типа ]\n\tсписок определений и инструкций\nEND\n",
        "type": "Statements"
    },
    "class": {
        "descr": "В языке RSL имеется возможность создавать классы и объекты. Классы и объекты, например, используются для поддержки программирования визуальной среды,\nв котором очень удобен объектно-ориентированный подход: такие ее специфические черты, как отчеты, кнопки, поля редактирования,\nпереключатели всегда можно представить в качестве объектов со своими свойствами и методами.\n\nВ языке RSL предусмотрено автоматическое создание объектов классов при первом обращении к декларированной переменной класса.\nЕсли конструктор класса имеет параметры, то в этом случае при создании объекта параметры будут иметь значение NULL\n\nЯзык RSL позволяет наследовать классы объектов от других классов.\nБазовый класс указывается в круглых скобках после ключевого слова CLASS.\nДля инициализации базового класса необходимо вызвать предопределенный метод, название которого образуется\nпутем добавления к имени класса приставки \"Init\". Вызов инициализатора базового класса может\nрасполагаться в любом месте определения дочернего класса\n\nМножественное наследование в языке RSL не поддерживается.\n\nОбращение к свойствам и методам класса осуществляется по имени\n\nКроме того, язык RSL поддерживает обращение к свойствам RSL-классов не только по имени, но и по индексу\n\nДля совместимости со стандартом автоматизации в языке RSL добавлена поддержка свойства по умолчанию.\nСвойством по умолчанию считается свойство, имя которого в выражении можно не указывать\n\nКлассы RSL могут иметь и свойства с параметрами. В настоящее время такие классы можно создать, например, при помощи специального инструмента DLM SDK.\nПараметры свойства аналогично параметрам метода указываются в круглых скобках\nКлассы языка RSL могут содержать деструктор, определяемый пользователем.\nДля его использования в определении класса необходимо указать метод с предопределенным именем Destructor.\nДеструктор вызывается автоматически при \"разрушении\" объекта. Если деструктор не определен, то все выделенные при создании объекта ресурсы освобождаются автоматически.\n\nВ коде методов все методы и свойства доступны непосредственно по имени.\nПри этом в каждый метод класса передается скрытый параметр this, представляющий собой ссылку на объект, для которого вызывается метод или свойство.\n\nСсылки на объекты хранятся в переменных RSL. При очистке переменной происходит удаление ссылки на объект.\nПеременная очищается перед присвоением ей нового значения либо при выходе из области видимости.\nТаким образом, объект класса будет существовать и его невозможно будет удалить до тех пор,\nпока на него есть хотя бы одна ссылка. При удалении последней ссылки на объект удаляется сам объект.\n\nОсобенностью использования RSL-классов, унаследованных от внешних классов, является невозможность обращения напрямую\nк методам родительского класса после того, как в дочернем классе эти методы были переопределены.\nДля этих целей служит стандартное свойство RSL-классов _extObj, возвращающее ссылку на внешний объект.\nЭто свойство позволяет переопределять методы базового класса в дочернем и сохраняет возможность вызова\nметодов базового класса",
        "name": "CLASS",
        "params": [
            {
                "descr": "это имя конструктора класса, которое используется при создании экземпляра данного класса.\n\tИспользование идентификатора класса в выражении создает экземпляр данного класса – объект.\n\tСписок формальных параметров содержит разделенные запятыми идентификаторы переменных, которые являются параметрами инициализатора объекта класса.\n\tВсе локальные переменные, находящиеся внутри определения класса, являются свойствами класса, а все локальные макропроцедуры – методами.\n\tЛюбой код внутри определения класса, не включенный в методы, является кодом конструктора",
                "name": "Идентификатор"
            },
            {
                "descr": "Если метод имеет параметры, то они указываются в круглых скобках аналогично параметрам макропроцедур RSL",
                "name": "Методы класса"
            }
        ],
        "path": "Конструкция_языка/CLASS",
        "syntax": "[local | private] Class [ '('идентификатор базового класса')'] идентификатор [' ('список формальных параметров')' ]\n\t<свойства класса>;\n\t<методы класса>;\nEnd\n",
        "type": "Statements"
    },
    "weakref": {
        "descr": "В языке RSL также предусмотрено использование так называемых \"слабых\" ссылок, которые не управляют временем жизни самого объекта,\nто есть объект можно удалить, если на него существуют \"слабые\" ссылки.\nМеханизм \"слабых\" ссылок в настоящее время поддерживается только для объектов классов, созданных на языке RSL.\n\"Слабая\" ссылка реализуется встроенным классом WeakRef",
        "name": "WEAKREF",
        "params": [
            {
                "descr": "Конструктор возвращает объект, который представляет собой \"слабую\" ссылку на объект obj. Этот объект в выражениях используется точно так же, как объект obj.\n\tПри попытке использовать \"слабую\" ссылку на объект, который уже удален, возникает ошибка времени исполнения.",
                "name": "WEAKREF"
            }
        ],
        "path": "Конструкция_языка/WEAKREF",
        "syntax": "WeakRef (obj:object) : object\n",
        "type": "Statements"
    },
    "with": {
        "descr": "Конструкция WITH применяется для обращения к конкретным экземплярам класса.",
        "name": "WITH",
        "params": [
            {
                "descr": "это имя переменной, содержащей ссылку на объект RSL-класса. Список инструкций выполняется для указанного объекта ",
                "name": "Идентификатор"
            }
        ],
        "path": "Конструкция_языка/WITH",
        "syntax": "WITH (идентификатор)\n\tсписок инструкций\nEND",
        "type": "Statements"
    },
    "import": {
        "descr": "В тексте программы может находиться директива IMPORT.\nИспользование этой директивы позволяет включить в текст макромодуля информацию из других файлов,\nчто дает возможность вынести часто используемые процедуры в отдельный файл\nи потом при необходимости подключать этот файл директивой IMPORT.\n\nДиректива IMPORT должна находиться вне определения макропроцедур\n\nДиректива IMPORT позволяет подключать:\n· другие RSL-модули, при этом имя модуля должно указываться без расширения\n\t(к нему будет по умолчанию добавлено расширение MAC);\n· DLM-модули – модули, созданные с помощью инструмента DLM SDK, которые имеют расширения D32, D16, DPM16, DLM.\n· встроенные в прикладную систему стандартные модули, которые написаны на языках C или C++.\n \nИмена модулей, подключаемых с помощью этой директивы, могут содержать русские буквы.\n\nПоиск указанных в директиве IMPORT файлов выполняется системой в следующей последовательности:\n· среди имен стандартных модулей, написанных на языке C/C++;\n· среди имен DLM-модулей;\n· среди имен текстовых файлов, имеющих расширение MAC. В этом случае система сначала осуществляет поиск файл\n\tс прекомпилированным кодом, который имеет такое же имя и расширение RSM, а затем ищет соответствующий ему макрофайл.\nЕсли для макрофайла существует актуальный файл с прекомпилированным кодом, то будет загружен соответствующий фай\nс расширением RSM. В противном случае загрузится файл с расширением MAC.",
        "name": "IMPORT",
        "params": [],
        "path": "Конструкция_языка/IMPORT",
        "syntax": "IMPORT \"FileName.mac\";\nimport FileName;",
        "type": "Statements"
    },
    "onerror": {
        "descr": "В языке RSL можно осуществить \"перехват\" любой ошибки, возникающей во время выполнения, не допустив аварийного завершения RSL-программы.\nДля этого любая макропроцедура RSL или метод класса может иметь обработчик ошибок\n\nЕсли какая-либо инструкция в теле макропроцедуры Test или инструкция в процедурах, вызванных из Test,\nгенерирует ошибку, то управление передается на первую инструкцию для обработки ошибок после ключевого слова OnError,\nи аварийного завершения RSL-программы не происходит.\n\nЕсли обработчику ошибок нужна информация о произошедшей ошибке, после ключевого слова OnError\nв скобках необходимо указать имя переменной (эта переменная может не декларироваться в теле макропроцедуры\nпри помощи ключевого слова VAR), которая после возникновения сбоя получит ссылку на\nспециальный объект класса TrslError, содержащий информацию о данной ошибке.\n\nОбъект класса TrslError имеет следующие свойства:\n· Codeкод ошибки;\n· Messageстрока, описывающая ошибку;\n· Moduleназвание модуля RSL, вызвавшего ошибку;\n· Lineстрока модуля, в которой произошла ошибка;\n· AxCodeкод ошибки ActiveX-объекта;\n· AxMesстрока с информацией об ошибке ActiveX-объекта.\n\nВ обработчике OnError можно получить информацию об ошибке пользователя при помощи обращения к полю err.\n\nЧтобы в обработчике заново сгенерировать ту же самую ошибку для передачи ее другому обработчику в цепочке\nвызовов макропроцедур или обработчику RSL, необходимо вызвать стандартную RSL-процедуру RunError без параметров.\n\nВ макромодуле, как и в макропроцедуре, можно реализовать обработчик ошибок.\nКлючевое слово END при этом не обязательно.\n\nПередача управления обработчику OnError происходит также при прерывании пользователем RSL-программы\nпо Ctrl+Break и при завершении программы процедурой Exit.\nВ обоих случаях генерируются специальные ошибки времени выполнения: для Ctrl+Break - код ошибки равен 17,\nдля Exit - код ошибки равен 0. Эти ошибки обрабатываются обработчиками OnError, как и любые другие ошибки RSL\nвремени выполнения. Но данные ошибки всегда пробрасываются дальше, даже если обработчик OnError не делает этого явно.\n\nКод, вызвавший RSL, в случае Ctrl+Break и Exit считает, что ошибок выполнения не было.",
        "name": "OnError",
        "params": [],
        "path": "ONERROR",
        "syntax": "Macro Test\n\t<инструкции RSL>\nOnError(er)\n\t<инструкции для обработки ошибок>\nEnd;",
        "type": "Statements"
    }
}
